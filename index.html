<!DOCTYPE html><head><title></title></head>
<style>
	canvas {
		margin: 50px auto 0 auto;
		border-radius: 5px;
		display: block;
		width: 960px;
	}
</style>
<body style="background:black;"><div id="music" style="display:none"></div><div id="itai" style="display:none"></div><div id="yummy" style="display:none"></div><script src="pixi.min.js"></script></script><script src="jquery-1.7.1.min.js"></script><script src="gapless5.js"></script><script>
if (window.console === undefined) {
	window.console = {'log' : function (str) {}};
};
l = console.log;

var difficulty = 0.3;

var itai = new Gapless5("itai", {
	loop: false, 
	tracks: "itai.wav"//, 
	// mapKeys: {cue: "1", playpause: "2", stop: "3"}
});

var yummy = new Gapless5("yummy", {
	loop: false, 
	tracks: "yummy.wav"//, 
	// mapKeys: {cue: "1", playpause: "2", stop: "3"}
});

// If objects can have negative coordinates, then you can give an offset.
// For example if your X coordinates go from -1000 to 1000, give an offsetX of 1000.
function makeCollisionGrid(w, h, cellSize, offsetX, offsetY) {
	var me = {};

	if ((w % cellSize) !== 0 || (h % cellSize) !== 0) {
		alert('w and h have to be evenly divisible by cellSize');
	}

	var xCells = (w / cellSize);
	var yCells = (h / cellSize);
	var cellCount = xCells * yCells;
	var field = new Array(cellCount);
	me.field = field;

	for (var i = 0; i < cellCount; i++) {
		field[i] = [];
	}

	// Obj needs to have playX, playY, radius
	me.add = function (obj) {
		var gridX = Math.floor((obj.playX + offsetX) / cellSize);
		var gridY = Math.floor((obj.playY + offsetY) / cellSize);
		var cellIndex = gridY * xCells + gridX;

		if (cellIndex < 0 || cellIndex >= cellCount) {
			l("Tried to add out-of-bounds object");
			l(obj);
		}

		field[cellIndex].push(obj);
	};

	me.remove = function (obj) {
		// l("removing");
		var gridX = Math.floor((obj.playX + offsetX) / cellSize);
		var gridY = Math.floor((obj.playY + offsetY) / cellSize);

		// Take it out from the grid cell it's in
		var cellIndex = gridY * xCells + gridX;
		var place = field[cellIndex].indexOf(obj);
		if (place === -1) {
			alert("object trying to remove wasn't in collisionGrid, although it should be, panic!");
		}
		field[cellIndex].splice(place, 1);
	}

	me.objMoved = function (obj, prevX, prevY) {
		if (obj.playX + offsetX < 0 || obj.playY + offsetX > w) {
			l("" + obj.name + " is outside grid: " + obj.playX + ", " + obj.playY);
		} 

		var oldGridX = Math.floor((prevX + offsetX) / cellSize);
		var oldGridY = Math.floor((prevY + offsetY) / cellSize);
		var newGridX = Math.floor((obj.playX + offsetX) / cellSize);
		var newGridY = Math.floor((obj.playY + offsetY) / cellSize);
		if (oldGridX === newGridX && oldGridY === newGridY) {
			return; // still in same cell, no need to do anything
		}

		// Take it out from the grid cell it used to be in
		var oldCellIndex = oldGridY * xCells + oldGridX;
		var place = field[oldCellIndex].indexOf(obj);
		if (place === -1) {
			alert("object wasn't in collisionGrid, although it should be, panic!");
		}
		field[oldCellIndex].splice(place, 1);

		// Put it in the new grid cell
		me.add(obj);
	}

	me.iterateObjs = function (callback) {
		for (var i = 0; i < cellCount; i++) {
			for (var j = 0; j < field[i].length; j++) {
				callback(field[i][j]);
			}
		}		
	};

	function objectsCollide(a, b) {
		var xdiff = a.playX - b.playX;
		var ydiff = a.playY - b.playY;
		return xdiff*xdiff + ydiff*ydiff <= a.radius*a.radius + 2*a.radius*b.radius + b.radius*b.radius;
	}

	me.findCollisions = function (collisionCallback) {
		// For each cell need to look at things in it and neighboring cells.
		for (var cellIndex = 0; cellIndex < cellCount; cellIndex++) {

			var cell = field[cellIndex];
			var length = cell.length;
			if (length === 0) continue;

			// for (var i = 0; i < length; i++) {
			// 	if (cell[i].name == "marimo") {
			// 		l(cellIndex);
			// 	}
			// }

			// Look for collisions inside this cell, but each pairwise only once
			for (var i = 0; i < length; i++) {
				for (var j = i + 1; j < length; j++) {
					if (objectsCollide(cell[i], cell[j])) {
						collisionCallback(cell[i], cell[j]);
					}
				}
			}

			// Things in this cell could also collide with things inside neighboring cells
			// var neighborCells = [
			// 	field[cellIndex - 1 - xCells],
			// 	field[cellIndex - xCells],
			// 	field[cellIndex + 1 - xCells],
			// 	field[cellIndex - 1],
			// 	field[cellIndex + 1],
			// 	field[cellIndex - 1 + xCells],
			// 	field[cellIndex + xCells],
			// 	field[cellIndex + 1 + xCells]
			// ];
			// for (var ci = 0; ci < neighborCells.length; ci++) {
			// 	var neighborCell = neighborCells[ci];
			// 	// l(neighborCell);
			// 	if (neighborCell === undefined) {
			// 		continue; // this can happen if out of bounds
			// 	}

			// 	var neighborCellLength = neighborCell.length;
			// 	// l(neighborCellLength);
			// 	for (var i = 0; i < length; i++) {
			// 		for (var j = 0; j < neighborCellLength; j++) {
			// 			if (objectsCollide(cell[i], neighborCell[j])) {
			// 	// 			collisionCallback(cell[i], neighborCell[j]);
			// 			}
			// 		}
			// 	}

			// 	// if (c !== undefined) {
			// 	// 	// Extend neighbors array with contents of cell
			// 	// 	Array.prototype.push.apply(neighbors, field[cellIndex - 1 - xCells]);
			// 	// }
			// }

			var neighbors = [];
			Array.prototype.push.apply(neighbors, field[cellIndex - 1 - xCells]);
			Array.prototype.push.apply(neighbors, field[cellIndex - xCells]);
			Array.prototype.push.apply(neighbors, field[cellIndex + 1 - xCells]);
			Array.prototype.push.apply(neighbors, field[cellIndex - 1]);
			Array.prototype.push.apply(neighbors, field[cellIndex + 1]);
			Array.prototype.push.apply(neighbors, field[cellIndex - 1 + xCells]);
			Array.prototype.push.apply(neighbors, field[cellIndex + xCells]);
			Array.prototype.push.apply(neighbors, field[cellIndex + 1 + xCells]);

			for (var i = 0; i < length; i++) {
				for (var j = 0, nl = neighbors.length; j < nl; j++) {
					if (objectsCollide(cell[i], neighbors[j])) {
						collisionCallback(cell[i], neighbors[j]);
					}
				}
			}
		}
	};

	return me;
};

var game = (function () {
	var keysDown = {};
	var me = {};
	var graphics = new PIXI.Graphics();
	var gravity = 0.001;
	var friction = 0.98;
	var bowlRadius = 1200;
	var escapeHeight = 160;
	var collisionGrid = makeCollisionGrid(2600, 2600, 40, 1300, 1300);

	var makeBlob = function () {
		var me = {
			dim_ys: -1,
			dim_y: 0,
			playY: 1180,
			playX: 0,
			xdir : 0,
			ydir : 0,
			xs: 0,
			ys: 0,
			oozeOffset : 0,
			movementSpeed : 0.00025,
			bigness : 0.05 + Math.random() * 0.3,
			name : 'unnamed',
			lastCollisionTime : 0,
			angularVelocity : 0
		};

		var blobRectangle = new PIXI.Rectangle(358, 1114, 100, 100);
		var baseTexture = PIXI.BaseTexture.fromImage("bg2.png");

		me.sprite = new PIXI.Sprite(
			new PIXI.Texture(
				baseTexture,
				blobRectangle
			)
		);

		me.sprite.initialHeight = me.sprite.height;
		me.sprite.initialWidth = me.sprite.width;

		me.sprite.anchor.set(0.5, 0.5);

		me.lastTwitch = 0;

		me.twitch = function () {
			me.lastTwitch = Date.now();
			if (me.name === "testblob") {
				me.xs = (Math.random() - 0.5) * 0.1;
				me.ys = (Math.random() - 0.5) * 0.1;
			} 
		};

		me.eat = function (amount) {
			me.bigness += amount;
			me.sprite.scale.set(me.bigness, me.bigness);
			me.radius = me.sprite.width / 2 * 0.75;
		};

		me.didCollideWith = function (b) {

			if (me.name == "marimo") {
//				itai.setPosition(0, true);
				// l("ouch");

				if (b.bigness < me.bigness) {

					var caloriesInSnack = b.bigness * difficulty;
					if (me.bigness > 1.5) caloriesInSnack = 0;
					me.eat(caloriesInSnack);

					// l(me.bigness);

					// b.sprite.visible = false;
					b.dead = true;

					if (me.name == "marimo") {
						yummy.stop();
						yummy.play();
					}

					return;
				} else {

					if (me.name == "marimo") {
						itai.stop();
						itai.play();
					}

					// Lose 25% of weight exceeding 0.1
					var weightLoss = Math.max(0, (me.bigness - 0.1) * 0.25);
					me.eat(-weightLoss);


				}
			}

			me.lastCollisionTime = Date.now();
			me.xs = (me.playX - b.playX) * 0.01;
			me.ys = (me.playY - b.playY) * 0.01;
			me.angularVelocity = Math.random() * Math.random();

		};

		me.tick = function (elapsed) {

			// Approx size for collision detection
			me.radius = me.sprite.width / 2 * 0.75;

			// l("" + me.name + " " + me.playX);

			// me.sprite.rotation = Date.now();

			var elapsedSinceLastCollision = Date.now() - me.lastCollisionTime;
			var canBeControlled = elapsedSinceLastCollision > 1000;
			if (!canBeControlled) {
				me.sprite.tint = 0xff0000;
				me.sprite.rotation += me.angularVelocity;
			} else {
				me.sprite.tint = me.name == "marimo" ? 0xffffff : 0x808080;
				me.sprite.rotation = me.sprite.rotation * 0.95;
				me.angularVelocity = 0;
			}

			// Underwater?
			if (me.playY > 0 && !me.escaped) {
				if (canBeControlled) me.ys += me.ydir * me.movementSpeed * elapsed;
				me.xs *= friction; 
				me.ys *= friction;
			} else {
				me.ys += elapsed * gravity; 
			}

			if (!me.escaped) {
				if (canBeControlled) me.xs += me.xdir * me.movementSpeed * elapsed;
			}

			me.prevX = me.playX;
			me.prevY = me.playY;

			me.playX += me.xs * elapsed;
			me.playY += me.ys * elapsed;

			// console.log("x:" + me.playX + ", y:" + me.playY);
			
			// If colliding with inside, reflect, except if high enough to escape
			if (Math.sqrt(me.playX * me.playX + me.playY * me.playY) > bowlRadius) {

				if (me.playY < -escapeHeight) {
					if (me.name == "marimo") { // only player can escape
						me.escaped = true;
					}
				}

				if (!me.escaped) {
					me.playX = me.prevX;
					me.playY = me.prevY;
					me.xs *= -1;
					me.ys *= -1; // This is wrong but whatevers for now
				}
			}

			// Twitch to music, or otherwise
			if (me.lastTwitch !== null) {
				var twitchElapsed = (Date.now() - me.lastTwitch) * 0.03;
				var t = (Math.sin(twitchElapsed)) * me.bigness * 20;
				if (twitchElapsed > Math.PI * 2) {
					me.lastTwitch = null; 
					t = 0;
				}
				me.sprite.height = me.sprite.initialHeight * me.bigness - t;
				me.sprite.width = me.sprite.initialWidth * me.bigness + t;
			}

			me.sprite.position.set(me.playX, me.playY);
			collisionGrid.objMoved(me, me.prevX, me.prevY);
		};

		return me;
	};

	var renderer = PIXI.autoDetectRenderer(960, 540); // an acceptable kongregate res
	renderer.backgroundColor = 0xFFFFFF;

	me.stage = new PIXI.Container();
	me.camera = new PIXI.Container();
	me.camera.targetScale = 5;
	me.camera.scale.set(me.camera.targetScale, me.camera.targetScale);
	me.camera.targetX = 960/2;
	me.camera.targetY = 540/2;
	me.camera.position.set(me.camera.targetX, me.camera.targetY);

	me.camera.tick = function () {

		var cameraSpeed = 0.5;

		me.camera.position.set(
			me.camera.position.x * cameraSpeed + me.camera.targetX * (1 - cameraSpeed),
			me.camera.position.y * cameraSpeed + me.camera.targetY * (1 - cameraSpeed)
		);

		me.camera.scale.set(
			me.camera.scale.x * 0.99 + me.camera.targetScale * 0.01,
			me.camera.scale.x * 0.99 + me.camera.targetScale * 0.01
		);

		me.camera.targetX = -me.blob.playX*me.camera.scale.x + 960/2;
		me.camera.targetY = -me.blob.playY*me.camera.scale.y + 540/2;
		me.camera.targetScale = 0.5 / me.blob.bigness;
		// me.camera.targetScale = 0.5;

		// me.camera.scale.set(0.5 / me.blob.bigness, 0.5 / me.blob.bigness);
	};

	graphics.beginFill(0x95998b);
	graphics.drawCircle(0, 0, bowlRadius + 10);
	graphics.endFill();

	graphics.beginFill(0x268dab);
	graphics.drawCircle(0, 0, bowlRadius);
	graphics.endFill();

	graphics.beginFill(0xffffff);
	graphics.drawRect(-1200, -bowlRadius*2, 2400, bowlRadius*2);
	graphics.endFill();

	me.camera.addChild(graphics);

	document.body.appendChild(renderer.view);

	me.controls = function() {

		var p = new PIXI.Rectangle(game.ima.mouse.global.x * 2, game.ima.mouse.global.y * 2, 100, 100);

		if (keysDown[87] || keysDown[83]) { // W / S
			me.blob.ydir = keysDown[87] ? -1 : 1;
		} else {
			me.blob.ydir = 0;
		}

		if (keysDown[65] || keysDown[68]) { // A / D
			me.blob.xdir = keysDown[65] ? -1 : 1;
		} else {
			me.blob.xdir = 0;
		}
	};

	var prevFrame = null;
	me.timeBased = function () {
		if (prevFrame === null) {
			prevFrame = Date.now();
			return;
		}
		var nau = Date.now();
		var elapsed = nau - prevFrame;

		var deadThings = [];
		collisionGrid.iterateObjs(function (obj) {
			if (obj.dead === true) {
				// l("" + obj.name + " has died");
				deadThings.push(obj);
				me.camera.removeChild(obj.sprite);				
			}
		});
		for (var i = 0; i < deadThings.length; i++) {
			collisionGrid.remove(deadThings[i]);
		}
	
		collisionGrid.iterateObjs(function (obj) {
			obj.tick(elapsed);
		});

		// me.blob.tick(elapsed);
		// me.blob2.tick(elapsed);

		prevFrame = nau;
	}

	me.beat = function() {
		collisionGrid.iterateObjs(function (obj) {
			if (obj.name != "marimo") {
				obj.twitch();
			}
		});

//		me.blob.twitch();
	}

	var beatPositions = [0, 0.25, 0.5, 0.75];
	var beatIndex = 0;

	var prevMusicPos = null;
	me.musicEvents = function() {
		var pos = me.music.mgr.sources[0].getPosition();
		if (prevMusicPos === null) {
			prevMusicPos = pos;
			return;
		}

		// Looped around?
		if (pos < prevMusicPos) {
			beatIndex = 0;
		}

		var len = me.music.mgr.sources[0].getLength();
		var r = pos / len;		

		if (beatIndex < beatPositions.length && r > beatPositions[beatIndex]) {
			beatIndex++;
			me.beat();
		}

		prevMusicPos = pos;
	};

	me.collisions = function () {
		collisionGrid.findCollisions(function (a, b) {
			a.didCollideWith(b);
			b.didCollideWith(a);
		});
	};

	me.animate = function () {
		me.timeBased();
		me.controls();
		me.camera.tick();
		me.musicEvents();

		var start = Date.now();

		if (!me.blob.escaped) {
			me.collisions();
		}
		var end = Date.now();
		var elapsed = end - start;

		if (elapsed > 1000/60) {
			l("collision detection took " + elapsed);
		}

		renderer.render(me.stage);
		requestAnimationFrame(me.animate);
	};

	function randomPointInsideCircle(radius) {
		var pt = {};
		while (true) {
			pt.x = Math.random() * radius * 2 - radius;
			pt.y = Math.random() * radius * 2 - radius;
			if (Math.sqrt(pt.x*pt.x + pt.y*pt.y) < radius) {
				return pt;
			}
		}
	}

	me.spawnEnemies = function () {
		var blob;
		for (var i = 0; i < 1000; i++) {
			var pt = randomPointInsideCircle(bowlRadius * 0.88);
			blob = makeBlob();
			blob.playX = pt.x;
			blob.playY = pt.y;
			blob.name = "testblob";
			collisionGrid.add(blob);

			me.camera.addChild(blob.sprite);
		}
	}

	me.assetsDidLoad = function () {
		// This is OK, it checks the texture cache based on image name so it isn't loaded twice
		// me.baseTexture = PIXI.BaseTexture.fromImage("bg.png");

		// me.sprite = new PIXI.Sprite(
		// 	new PIXI.Texture(
		// 		me.baseTexture,
		// 		new PIXI.Rectangle(0, 1000, 1000, 1000)
		// 	)
		// );

		me.stage.addChild(me.camera);
		me.blob = makeBlob();
		me.blob.name = "marimo";
		me.blob.bigness = 0.1;
		collisionGrid.add(me.blob);
		// l(me.blob.playX);
		// l(me.blob.playY);

		me.spawnEnemies();
		me.camera.addChild(me.blob.sprite);

		requestAnimationFrame(me.animate);
	}

	me.loader = PIXI.loader
	    .add([
	    	'bg2.png'
	    ])
	    .load(me.assetsDidLoad);

	me.ima = new PIXI.interaction.InteractionManager(renderer);

	document.body.onkeydown = function(e) {
		if (keysDown[event.keyCode]) return;

		if ([87, 83, 65, 68].indexOf(event.keyCode) !== -1) {
			me.blob.twitch();
		}

		// if (event.keyCode == 66) {
		// 	me.blob.eat();
		// }

		// l(event.keyCode);

		keysDown[event.keyCode] = true;
	}

	document.body.onkeyup = function(e) {
		delete keysDown[event.keyCode];
	}

	me.music = new Gapless5("music", {
		loop: true, 
		tracks: "music.wav"//, 
		// mapKeys: {cue: "1", playpause: "2", stop: "3"}
	});
	me.music.play();

	

	return me;
})();

// document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></' + 'script>');

$(function() {
});</script></body></html>