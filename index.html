<!DOCTYPE html><head><title></title></head>
<style>
	canvas {
		margin: 50px auto 0 auto;
		border-radius: 5px;
		display: block;
		width: 960px;
	}
</style>
<body style="background:black;"><div id="music" style="display:none"/><script src="pixi.min.js"></script></script><script src="jquery-1.7.1.min.js"></script><script src="gapless5.js"></script><script>
if (!window.console) {
	window.console = {'log' : function (str) {}};
};
l = console.log;

var bulletField = function (w, h, maxRadius) {
	var me = {};

	me.addBullet = function (x, y, radius) {

	};

	me.findCollisions = function () {
		var collisions = [];
		return collisions;
	};

	return me;
};

var game = (function () {
	var keysDown = {};
	var me = {};
	var graphics = new PIXI.Graphics();
	var gravity = 0.001;
	var friction = 0.95;
	var bowlRadius = 1200;
	var escapeHeight = 160;

	var makeBlob = function () {
		var me = {
			dim_ys: -1,
			dim_y: 0,
			playY: 200,
			playX: 200,
			xs: 0,
			ys: 0,
			oozeOffset : 0,
			movementSpeed : 0.0025,
			bigness : 0.1
		};

		var blobRectangle = new PIXI.Rectangle(358, 1114, 100, 100);
		var baseTexture = PIXI.BaseTexture.fromImage("bg.png");

		me.sprite = new PIXI.Sprite(
			new PIXI.Texture(
				baseTexture,
				blobRectangle
			)
		);

		me.sprite.initialHeight = me.sprite.height;
		me.sprite.initialWidth = me.sprite.width;

		me.sprite.anchor.set(0.5, 0.5);

		me.lastTwitch = 0;

		me.twitch = function () {
			me.lastTwitch = Date.now();
		}

		me.eat = function () {
			l(me.sprite.scale);

			me.bigness *= 1.1;
			me.sprite.scale.set(me.bigness, me.bigness);
		}

		me.tick = function (elapsed) {
			// me.sprite.rotation = Date.now();

			// Underwater?
			if (me.playY > 0 && !me.escaped) {
				me.ys += me.ydir * me.movementSpeed * elapsed;
				me.xs *= friction; 
				me.ys *= friction;
			} else {
				me.ys += elapsed * gravity; 
			}

			if (!me.escaped) {
				me.xs += me.xdir * me.movementSpeed * elapsed;
			}

			me.prevX = me.playX;
			me.prevY = me.playY;

			me.playX += me.xs * elapsed;
			me.playY += me.ys * elapsed;

			// If colliding with inside, reflect, except if high enough to escape
			if (Math.sqrt(me.playX * me.playX + me.playY * me.playY) > bowlRadius) {

				if (me.playY < -escapeHeight) {
					me.escaped = true;
				}

				if (!me.escaped) {
					me.playX = me.prevX;
					me.playY = me.prevY;
					me.xs *= -1;
					me.ys *= -1; // This is wrong but whatevers for now
				}
			}

			// Twitch to music, or otherwise
			if (me.lastTwitch !== null) {
				var twitchElapsed = (Date.now() - me.lastTwitch) * 0.03;
				var t = (Math.sin(twitchElapsed)) * 10;
				if (twitchElapsed > Math.PI * 2) {
					me.lastTwitch = null; 
					t = 0;
				}
				me.sprite.height = me.sprite.initialHeight * me.bigness - t;
				me.sprite.width = me.sprite.initialWidth * me.bigness + t;
			}

			me.sprite.position.set(me.playX, me.playY);
		};

		return me;
	};

	var renderer = PIXI.autoDetectRenderer(960, 540); // an acceptable kongregate res
	renderer.backgroundColor = 0xFFFFFF;

	me.stage = new PIXI.Container();
	me.camera = new PIXI.Container();
	me.camera.targetScale = 5;
	me.camera.scale.set(me.camera.targetScale, me.camera.targetScale);
	me.camera.targetX = 960/2;
	me.camera.targetY = 540/2;
	me.camera.position.set(me.camera.targetX, me.camera.targetY);

	me.camera.tick = function () {

		var cameraSpeed = 0.5;

		me.camera.position.set(
			me.camera.position.x * cameraSpeed + me.camera.targetX * (1 - cameraSpeed),
			me.camera.position.y * cameraSpeed + me.camera.targetY * (1 - cameraSpeed)
		);

		me.camera.scale.set(
			me.camera.scale.x * 0.999 + me.camera.targetScale * 0.001,
			me.camera.scale.x * 0.999 + me.camera.targetScale * 0.001
		);

		me.camera.targetX = -me.blob.playX*me.camera.scale.x + 960/2;
		me.camera.targetY = -me.blob.playY*me.camera.scale.y + 540/2;
		me.camera.targetScale = 0.5 / me.blob.bigness;

//		me.camera.scale.set(0.5 / me.blob.bigness, 0.5 / me.blob.bigness);
	};

	graphics.beginFill(0x95998b);
	graphics.drawCircle(0, 0, bowlRadius + 10);
	graphics.endFill();

	graphics.beginFill(0x268dab);
	graphics.drawCircle(0, 0, bowlRadius);
	graphics.endFill();

	graphics.beginFill(0xffffff);
	graphics.drawRect(-1200, -bowlRadius*2, 2400, bowlRadius*2);
	graphics.endFill();

	me.camera.addChild(graphics);

//	me.camera.scale.set(0.5, 0.5);

	document.body.appendChild(renderer.view);

	// bg.position.x = 0;
	// bg.position.y = 0;
	// bg.scale.x = 0.25;
	// bg.scale.y = 0.25;
	// stage.addChild(bg);

	// var count = 0;
	// var prevPos = null;


	me.controls = function() {

		var p = new PIXI.Rectangle(game.ima.mouse.global.x * 2, game.ima.mouse.global.y * 2, 100, 100);

		if (keysDown[87] || keysDown[83]) { // W / S
//			me.blob.ys = keysDown[87] ? -me.blob.movementSpeed : me.blob.movementSpeed;
			me.blob.ydir = keysDown[87] ? -1 : 1;
		} else {
			me.blob.ydir = 0;
		}

		if (keysDown[65] || keysDown[68]) { // A / D
//			me.blob.xs = keysDown[65] ? -me.blob.movementSpeed : me.blob.movementSpeed;
			me.blob.xdir = keysDown[65] ? -1 : 1;
		} else {
			me.blob.xdir = 0;
		}

		// if (keysDown[83]) { // S
		// 	me.blob.ys = me.blob.movementSpeed;
		// }
		// if (keysDown[68]) { // D
		// 	me.blob.xs = me.blob.movementSpeed;
		// }


		// l(p);
		// me.sprite2.texture.frame = p;

		// l(game.ima.mouse.global.x, game.ima.mouse.global.y);
	};

	var prevFrame = null;
	me.timeBased = function () {
		if (prevFrame === null) {
			prevFrame = Date.now();
			return;
		}
		var nau = Date.now();
		var elapsed = nau - prevFrame;

		me.blob.tick(elapsed);

		prevFrame = nau;
	}

	me.beat = function() {
		me.blob.twitch();
	}

	var beatPositions = [0, 0.25, 0.5, 0.75];
	var beatIndex = 0;

	var prevMusicPos = null;
	me.musicEvents = function() {
		var pos = me.music.mgr.sources[0].getPosition();
		if (prevMusicPos === null) {
			prevMusicPos = pos;
			return;
		}

		// Looped around?
		if (pos < prevMusicPos) {
			beatIndex = 0;
		}

		var len = me.music.mgr.sources[0].getLength();
		var r = pos / len;		

		if (beatIndex < beatPositions.length && r > beatPositions[beatIndex]) {
			beatIndex++;
			me.beat();
		}

		prevMusicPos = pos;
	};

	me.animate = function () {
		// count += 0.1;
		me.timeBased();
		me.controls();
		me.camera.tick();
		me.musicEvents();

		renderer.render(me.stage);
		requestAnimationFrame(me.animate);
	};

	me.assetsDidLoad = function () {
		// This is OK, it checks the texture cache based on image name so it isn't loaded twice
		// me.baseTexture = PIXI.BaseTexture.fromImage("bg.png");

		// me.sprite = new PIXI.Sprite(
		// 	new PIXI.Texture(
		// 		me.baseTexture,
		// 		new PIXI.Rectangle(0, 1000, 1000, 1000)
		// 	)
		// );

		me.stage.addChild(me.camera);
		me.blob = makeBlob();
		me.camera.addChild(me.blob.sprite);


		// me.stage.addChild(me.sprite);
		

		requestAnimationFrame(me.animate);
	}

	me.loader = PIXI.loader
	    .add([
	    	'bg.png'
	    ])
	    .load(me.assetsDidLoad);

	me.ima = new PIXI.interaction.InteractionManager(renderer);

	document.body.onkeydown = function(e) {
		if (keysDown[event.keyCode]) return;

		if ([87, 83, 65, 68].indexOf(event.keyCode) !== -1) {
			me.blob.twitch();
		}

		if (event.keyCode == 66) {
			me.blob.eat();
		}

		// l(event.keyCode);

		keysDown[event.keyCode] = true;
	}

	document.body.onkeyup = function(e) {
		delete keysDown[event.keyCode];
	}

	me.music = new Gapless5("music", {
		loop: true, 
		tracks: "music.wav", 
		mapKeys: {cue: "1", playpause: "2", stop: "3"}
	});
//	me.music.play();

	return me;
})();

// document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></' + 'script>');

$(function() {
});</script></body></html>